# 堆（Heap）和栈（Stack）内存比较 — 笔记

---

## 一、栈（Stack）

### 1. 内存布局和特点

- 栈是**连续的一块内存区域**，由操作系统为每个线程分配固定大小的空间（通常几MB）。  
- 栈上的内存管理非常简单，采用**后进先出（LIFO）**的规则。  
- 访问速度快，分配和释放都由编译器自动管理（函数调用时分配，函数返回时释放）。

### 2. 存储内容

- 局部变量（基本类型、对象实例）  
- 函数调用时的返回地址、参数  
- 栈帧（Stack Frame）

### 3. 优势

- 分配速度快（只需要移动栈指针）  
- 自动管理，无需手动释放，减少内存泄漏风险  
- 缓存友好，连续内存利用率高

### 4. 限制

- 栈空间有限，不适合分配大块内存  
- 不能跨函数传递存活时间超过函数调用的变量  
- 不适合动态大小的内存需求

---

## 二、堆（Heap）

### 1. 内存布局和特点

- 堆是**不连续的内存区域**，用于动态分配内存，大小受系统可用内存限制。  
- 程序员需要手动管理堆内存（`new` / `delete`，`malloc` / `free`）。  
- 堆内存分配复杂，通常有空闲块链表（free list）等数据结构管理碎片。

### 2. 存储内容

- 动态创建的对象和数据（例如用 `new` 分配的对象）  
- 需要在多个函数间共享或长期存在的数据

### 3. 优势

- 灵活，适合动态和大块内存分配  
- 对象生命周期可跨函数控制

### 4. 缺点

- 分配和释放速度比栈慢（需要搜索空闲块、维护内存链表）  
- 需要手动管理，易产生内存泄漏和悬挂指针  
- 内存碎片问题可能导致效率降低

---

## 三、栈和堆的对比总结

| 特性     | 栈（Stack）                 | 堆（Heap）                     |
|----------|-----------------------------|-------------------------------|
| 内存布局 | 连续                        | 不连续                        |
| 分配释放 | 编译器自动管理              | 程序员手动管理                |
| 速度     | 非常快                      | 较慢                          |
| 空间大小 | 有限（几MB）                | 较大（受系统内存限制）        |
| 使用场景 | 局部变量、函数调用上下文    | 动态分配的大块内存、跨函数生命周期的数据 |
| 风险     | 栈溢出（过深递归或大局部变量） | 内存泄漏、碎片化、悬挂指针      |

---  
栈的分配就是反向移动栈指针，然后返回栈地址，那就是内存块的开始。  
当想用堆的时候，new 会调用malloc ，然后malloc会有个free list需要查看有哪些空余的内存，然后分配过去，然后还要计算分配了多少还剩多少,非常麻烦
实际编程建议（The Cherno 提醒）尽量使用栈，因为它速度快，管理简单。  
只有当栈空间不够，或者需要动态生命周期管理时，才用堆。  


